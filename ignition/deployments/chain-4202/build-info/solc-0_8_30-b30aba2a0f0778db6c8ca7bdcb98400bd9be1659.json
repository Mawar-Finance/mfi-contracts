{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-b30aba2a0f0778db6c8ca7bdcb98400bd9be1659",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/savings/SavingsVault.sol": "project/contracts/savings/SavingsVault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.5/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.5/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "project/contracts/interfaces/IMFI.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/// @notice Minimal interface ERC20 yang kita butuh (tanpa mint)\r\ninterface IMFI {\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISavingsNFT.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\ninterface ISavingsNFT {\r\n    function mint(address to, uint8 initialRoses) external returns (uint256 tokenId);\r\n    function upgrade(uint256 tokenId, uint8 addRoses) external;\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function roseCountOf(uint256 tokenId) external view returns (uint8);\r\n    function isFull(uint256 tokenId) external view returns (bool);\r\n}\r\n"
      },
      "project/contracts/libs/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/// @notice Custom errors (hemat gas)\r\nlibrary Errors {\r\n    error ZeroAddress();\r\n    error InvalidAmount();\r\n    error NotMultipleOfRoseUnit();\r\n    error ExceedsMaxRoses();\r\n    error NotTokenOwner();\r\n    error Unauthorized();\r\n}\r\n"
      },
      "project/contracts/savings/SavingsVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"../interfaces/IMFI.sol\";\r\nimport \"../interfaces/ISavingsNFT.sol\";\r\nimport \"../libs/Errors.sol\";\r\n\r\n/// @title SavingsVault - Nabung & Redeem (tanpa admin/role)\r\n/// @dev Semua parameter kunci dikunci saat deploy (immutable).\r\ncontract SavingsVault is ReentrancyGuard {\r\n    IMFI public immutable mfi;\r\n    ISavingsNFT public immutable nft;\r\n\r\n    /// @notice fee (bps) dikunci saat deploy. 250 = 2.5%\r\n    uint16 public immutable feeBps;\r\n\r\n    /// @notice alamat penerima fee (dikunci saat deploy)\r\n    address public immutable treasury;\r\n\r\n    /// @notice 1 mawar = 10 MFI (18 desimal)\r\n    uint256 public constant ROSE_UNIT = 10 * 1e18;\r\n\r\n    /// @dev buket aktif per user (0 jika tidak ada)\r\n    mapping(address => uint256) public activeBucketId;\r\n\r\n    /// @dev array token IDs yang dimiliki user\r\n    mapping(address => uint256[]) private userDeposits;\r\n    /// @dev index (plus one) dari tokenId di array userDeposits[user]\r\n    mapping(uint256 => uint256) private depositIndex;\r\n\r\n    event Deposited(address indexed user, uint256 amountMFI, uint256 rosesAdded);\r\n    event NFTMinted(address indexed user, uint256 indexed tokenId, uint8 roseCount);\r\n    event NFTUpgraded(address indexed user, uint256 indexed tokenId, uint8 oldCount, uint8 newCount);\r\n    event Redeemed(address indexed user, uint256 indexed tokenId, uint256 principal, uint256 fee, uint256 payout);\r\n\r\n    /// @param _mfi alamat token MFI\r\n    /// @param _nft alamat SavingsNFT\r\n    /// @param _treasury alamat penerima fee\r\n    /// @param _feeBps fee dalam bps (misal 250 = 2.5%)\r\n    constructor(IMFI _mfi, ISavingsNFT _nft, address _treasury, uint16 _feeBps) {\r\n        if (address(_mfi) == address(0) || address(_nft) == address(0) || _treasury == address(0)) {\r\n            revert Errors.ZeroAddress();\r\n        }\r\n        mfi = _mfi;\r\n        nft = _nft;\r\n        treasury = _treasury;\r\n        feeBps = _feeBps;\r\n    }\r\n\r\n    /// @notice Deposit MFI kelipatan 10 → upgrade/mint buket\r\n    function deposit(uint256 amount) external nonReentrant {\r\n        if (amount == 0) revert Errors.InvalidAmount();\r\n        if (amount % ROSE_UNIT != 0) revert Errors.NotMultipleOfRoseUnit();\r\n\r\n        // Tarik MFI dari user ke vault\r\n        bool ok = mfi.transferFrom(msg.sender, address(this), amount);\r\n        require(ok, \"MFI transferFrom failed\");\r\n\r\n        uint256 rosesToAdd = amount / ROSE_UNIT;\r\n        emit Deposited(msg.sender, amount, rosesToAdd);\r\n\r\n        uint256 tokenId = activeBucketId[msg.sender];\r\n\r\n        while (rosesToAdd > 0) {\r\n            if (tokenId == 0) {\r\n                // mint buket baru\r\n                uint8 initial = uint8(rosesToAdd > 10 ? 10 : rosesToAdd);\r\n                tokenId = nft.mint(msg.sender, initial);\r\n                activeBucketId[msg.sender] = tokenId;\r\n                // Track deposit\r\n                userDeposits[msg.sender].push(tokenId);\r\n                depositIndex[tokenId] = userDeposits[msg.sender].length; // store index+1\r\n                emit NFTMinted(msg.sender, tokenId, initial);\r\n                rosesToAdd -= initial;\r\n                if (initial == 10) {\r\n                    tokenId = 0; // penuh → siap mint baru di loop berikutnya\r\n                }\r\n            } else {\r\n                // upgrade buket aktif\r\n                uint8 current = nft.roseCountOf(tokenId);\r\n                if (current == 10) {\r\n                    activeBucketId[msg.sender] = 0;\r\n                    tokenId = 0;\r\n                    continue;\r\n                }\r\n                uint8 canAdd = uint8(10 - current);\r\n                uint8 add = uint8(rosesToAdd > canAdd ? canAdd : rosesToAdd);\r\n                nft.upgrade(tokenId, add);\r\n                emit NFTUpgraded(msg.sender, tokenId, current, current + add);\r\n                rosesToAdd -= add;\r\n                if (current + add == 10) {\r\n                    activeBucketId[msg.sender] = 0;\r\n                    tokenId = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Redeem penuh 1 NFT → burn & kirim MFI (principal-fee) ke user, fee ke treasury\r\n    function redeem(uint256 tokenId) external nonReentrant {\r\n        if (nft.ownerOf(tokenId) != msg.sender) revert Errors.NotTokenOwner();\r\n\r\n        (uint256 principal, uint256 fee, uint256 payout) = previewRedeem(tokenId);\r\n\r\n        // burn NFT\r\n        nft.burn(tokenId);\r\n        if (activeBucketId[msg.sender] == tokenId) {\r\n            activeBucketId[msg.sender] = 0;\r\n        }\r\n\r\n        // Remove from userDeposits using swap-pop\r\n        uint256 idxPlusOne = depositIndex[tokenId];\r\n        if (idxPlusOne > 0) {\r\n            uint256 idx = idxPlusOne - 1;\r\n            uint256 lastIdx = userDeposits[msg.sender].length - 1;\r\n            \r\n            if (idx != lastIdx) {\r\n                // Swap with last element\r\n                uint256 lastToken = userDeposits[msg.sender][lastIdx];\r\n                userDeposits[msg.sender][idx] = lastToken;\r\n                depositIndex[lastToken] = idx + 1;\r\n            }\r\n            userDeposits[msg.sender].pop();\r\n            depositIndex[tokenId] = 0;\r\n        }\r\n\r\n        // kirim fee ke treasury (jika > 0)\r\n        if (fee > 0) {\r\n            bool okFee = mfi.transfer(treasury, fee);\r\n            require(okFee, \"MFI fee transfer failed\");\r\n        }\r\n\r\n        // kirim payout ke user\r\n        bool okUser = mfi.transfer(msg.sender, payout);\r\n        require(okUser, \"MFI payout transfer failed\");\r\n\r\n        emit Redeemed(msg.sender, tokenId, principal, fee, payout);\r\n    }\r\n\r\n    /// @notice Simulasi hitung nilai redeem\r\n    function previewRedeem(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (uint256 principal, uint256 fee, uint256 payout)\r\n    {\r\n        uint8 roses = nft.roseCountOf(tokenId);\r\n        principal = uint256(roses) * ROSE_UNIT;\r\n        fee = (principal * feeBps) / 10_000;\r\n        payout = principal - fee;\r\n    }\r\n\r\n    /// @notice Get semua token IDs yang dimiliki user\r\n    /// @param user Alamat user yang dicari depositnya\r\n    /// @return Array dari token IDs yang dimiliki user\r\n    function getUserDeposits(address user) external view returns (uint256[] memory) {\r\n        if (user == address(0)) {\r\n            return new uint256[](0);\r\n        }\r\n        // Empty array if no deposits yet\r\n        if (userDeposits[user].length == 0) {\r\n            return new uint256[](0);\r\n        }\r\n        return userDeposits[user];\r\n    }\r\n}\r\n"
      }
    }
  }
}