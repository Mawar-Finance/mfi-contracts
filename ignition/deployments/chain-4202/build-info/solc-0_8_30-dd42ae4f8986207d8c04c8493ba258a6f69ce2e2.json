{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-dd42ae4f8986207d8c04c8493ba258a6f69ce2e2",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/savings/SavingsVault.sol": "project/contracts/savings/SavingsVault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.5/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.5/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "project/contracts/interfaces/IMFI.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/// @title IMFI (Minimal ERC20 Interface)\r\n/// @notice Antarmuka minimal token MFI yang dipakai di project (tanpa fungsi mint/burn)\r\n/// @dev Hanya expose fungsi yang dibutuhkan Vault/Frontend: decimals, balanceOf, transfer, transferFrom\r\ninterface IMFI {\r\n    /// @notice Jumlah desimal yang dipakai token (contoh: 18)\r\n    /// @dev Berguna buat konversi UI (mis. 1 MFI = 10**decimals)\r\n    /// @return uint8 Banyaknya desimal\r\n    function decimals() external view returns (uint8);\r\n\r\n    /// @notice Cek saldo MFI milik `account`\r\n    /// @param account Alamat yang dicek saldonya\r\n    /// @return uint256 Saldo dalam satuan paling kecil (wei-nya token)\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /// @notice Transfer MFI dari caller (msg.sender) ke `to`\r\n    /// @dev Mengembalikan true kalau sukses; biasanya revert kalau gagal\r\n    /// @param to Penerima token\r\n    /// @param amount Jumlah token (dalam satuan paling kecil)\r\n    /// @return bool Status sukses transfer\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /// @notice Transfer MFI dari `from` ke `to` menggunakan allowance\r\n    /// @dev Butuh `approve` sebelumnya dari `from` ke caller minimal sebesar `amount`\r\n    /// @param from Pemilik token yang di-debit\r\n    /// @param to Penerima token\r\n    /// @param amount Jumlah token (dalam satuan paling kecil)\r\n    /// @return bool Status sukses transfer\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISavingsNFT.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n// interface for SavingsNFT\r\n// function yg ada disini sesuai dg yg diimplement di SavingsNFT.sol\r\n// apabila ada function baru di SavingsNFT.sol harus ditambah di interface ini.\r\ninterface ISavingsNFT {\r\n    function mint(address to, uint8 initialRoses) external returns (uint256 tokenId);       // untuk membuat NFT baru.\r\n    function upgrade(uint256 tokenId, uint8 addRoses) external;                             // meng-upgrade jumlah mawar di NFT yg sudah ada.\r\n    function burn(uint256 tokenId) external;                                                // menghancur NFT saat redeem.\r\n    \r\n    function balanceOf(address owner) external view returns (uint256);                      // jumlah NFT yg dimiliki owner\r\n    function ownerOf(uint256 tokenId) external view returns (address);                      // pemilik NFT berdasarkan tokenId\r\n    function roseCountOf(uint256 tokenId) external view returns (uint8);                    // jumlah mawar di NFT berdasarkan tokenId\r\n    function isFull(uint256 tokenId) external view returns (bool);                          // apakah NFT sudah penuh (10 mawar) \r\n}\r\n"
      },
      "project/contracts/libs/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/// @notice Custom errors (hemat gas)\r\nlibrary Errors {\r\n    error ZeroAddress();\r\n    error InvalidAmount();\r\n    error NotMultipleOfRoseUnit();\r\n    error ExceedsMaxRoses();\r\n    error NotTokenOwner();\r\n    error Unauthorized();\r\n}\r\n"
      },
      "project/contracts/savings/SavingsVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;                            // Versi Solidity\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";   // Cegah serangan reentrancy\r\nimport \"../interfaces/IMFI.sol\";                                  // Interface token MFI (ERC20)\r\nimport \"../interfaces/ISavingsNFT.sol\";                           // Interface NFT tabungan\r\nimport \"../libs/Errors.sol\";                                      // Custom error collection\r\n\r\n/// @title SavingsVault - Nabung & Redeem (tanpa admin/role)\r\n/// @dev Semua parameter penting dikunci saat deploy (immutable).\r\ncontract SavingsVault is ReentrancyGuard {\r\n    IMFI public immutable mfi;                     // Token MFI, immutable artinya tidak bisa diubah\r\n    ISavingsNFT public immutable nft;              // NFT bunga mawar\r\n    uint16 public immutable feeBps;                // Fee platform dalam basis poin (bps)\r\n    address public immutable treasury;             // Alamat penerima fee platform\r\n\r\n    uint256 public constant ROSE_UNIT = 10 * 1e18; // 1 mawar = 10 MFI\r\n\r\n    mapping(address => uint256) public activeBucketId; // Simpan tokenId buket aktif tiap user\r\n\r\n    mapping(address => uint256[]) private userDeposits; // List semua NFT (buket) milik user\r\n    mapping(uint256 => uint256) private depositIndex;   // Posisi tokenId dalam array userDeposits[user]\r\n\r\n    event Deposited(address indexed user, uint256 amountMFI, uint256 rosesAdded);  // Event deposit\r\n    event NFTMinted(address indexed user, uint256 indexed tokenId, uint8 roseCount); // Event mint NFT baru\r\n    event NFTUpgraded(address indexed user, uint256 indexed tokenId, uint8 oldCount, uint8 newCount); // Event upgrade NFT\r\n    event Redeemed(address indexed user, uint256 indexed tokenId, uint256 principal, uint256 fee, uint256 payout); // Event redeem\r\n\r\n    constructor(IMFI _mfi, ISavingsNFT _nft, address _treasury, uint16 _feeBps) {\r\n        if (address(_mfi) == address(0) || address(_nft) == address(0) || _treasury == address(0)) {\r\n            revert Errors.ZeroAddress();            // Cegah alamat kosong\r\n        }\r\n        mfi = _mfi;                                // Set alamat kontrak MFI\r\n        nft = _nft;                                // Set alamat kontrak NFT\r\n        treasury = _treasury;                      // Set penerima fee\r\n        feeBps = _feeBps;                          // Set fee (dalam bps)\r\n    }\r\n\r\n    /// @notice Deposit MFI kelipatan 10 → upgrade/mint buket\r\n    function deposit(uint256 amount) external nonReentrant {\r\n        if (amount == 0) revert Errors.InvalidAmount();         // Cegah deposit nol\r\n        if (amount % ROSE_UNIT != 0) revert Errors.NotMultipleOfRoseUnit(); // Harus kelipatan 10 MFI\r\n\r\n        bool ok = mfi.transferFrom(msg.sender, address(this), amount);      // Transfer MFI dari user ke vault\r\n        require(ok, \"MFI transferFrom failed\");                             // Pastikan berhasil\r\n\r\n        uint256 rosesToAdd = amount / ROSE_UNIT;                            // Hitung berapa mawar yang ditambah\r\n        emit Deposited(msg.sender, amount, rosesToAdd);                     // Log event\r\n\r\n        uint256 tokenId = activeBucketId[msg.sender];                       // Ambil NFT aktif user (0 kalau belum ada)\r\n\r\n        while (rosesToAdd > 0) {                                            // Selama masih ada mawar tersisa buat ditambah\r\n            if (tokenId == 0) {                                             // Kalau user belum punya buket aktif\r\n                uint8 initial = uint8(rosesToAdd > 10 ? 10 : rosesToAdd);   // Ambil max 10 mawar\r\n                tokenId = nft.mint(msg.sender, initial);                    // Mint NFT baru\r\n                activeBucketId[msg.sender] = tokenId;                       // Set NFT ini jadi aktif\r\n                userDeposits[msg.sender].push(tokenId);                     // Simpan ke daftar milik user\r\n                depositIndex[tokenId] = userDeposits[msg.sender].length;    // Simpan index+1 buat tracking\r\n                emit NFTMinted(msg.sender, tokenId, initial);               // Log mint event\r\n                rosesToAdd -= initial;                                      // Kurangi mawar yang udah dipakai\r\n                if (initial == 10) tokenId = 0;                             // Kalau sudah penuh, reset untuk loop berikutnya\r\n            } else {                                                        // Kalau user punya NFT aktif\r\n                uint8 current = nft.roseCountOf(tokenId);                   // Ambil jumlah mawar sekarang\r\n                if (current == 10) {                                        // Kalau sudah penuh, reset ke 0\r\n                    activeBucketId[msg.sender] = 0;\r\n                    tokenId = 0;\r\n                    continue;                                               // Lanjut ke loop berikutnya\r\n                }\r\n                uint8 canAdd = uint8(10 - current);                             // Hitung berapa mawar bisa ditambah\r\n                uint8 add = uint8(rosesToAdd > canAdd ? canAdd : rosesToAdd);   // Pilih jumlah yang bisa\r\n                nft.upgrade(tokenId, add);                                      // Upgrade NFT dengan tambahan mawar\r\n                emit NFTUpgraded(msg.sender, tokenId, current, current + add);  // Log event\r\n                rosesToAdd -= add;                                              // Kurangi sisa mawar\r\n                if (current + add == 10) {                                      // Kalau sudah penuh\r\n                    activeBucketId[msg.sender] = 0;                             // Reset NFT aktif\r\n                    tokenId = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Redeem penuh 1 NFT → burn & kirim MFI (principal-fee)\r\n    function redeem(uint256 tokenId) external nonReentrant {\r\n        if (nft.ownerOf(tokenId) != msg.sender) revert Errors.NotTokenOwner();          // Pastikan pemilik sah\r\n\r\n        (uint256 principal, uint256 fee, uint256 payout) = previewRedeem(tokenId);      // Hitung nilai redeem\r\n\r\n        nft.burn(tokenId);                                                              // Burn NFT\r\n        if (activeBucketId[msg.sender] == tokenId) activeBucketId[msg.sender] = 0;      // Reset jika aktif\r\n\r\n        uint256 idxPlusOne = depositIndex[tokenId];                                     // Ambil index token di array userDeposits\r\n        if (idxPlusOne > 0) {                                                           // Jika ditemukan\r\n            uint256 idx = idxPlusOne - 1;\r\n            uint256 lastIdx = userDeposits[msg.sender].length - 1;\r\n\r\n            if (idx != lastIdx) {                                                       // Jika bukan elemen terakhir\r\n                uint256 lastToken = userDeposits[msg.sender][lastIdx];                  // Ambil token terakhir\r\n                userDeposits[msg.sender][idx] = lastToken;                              // Ganti posisi\r\n                depositIndex[lastToken] = idx + 1;                                      // Update index baru\r\n            }\r\n            userDeposits[msg.sender].pop();                                             // Hapus elemen terakhir\r\n            depositIndex[tokenId] = 0;                                                  // Hapus index token ini\r\n        }\r\n\r\n        if (fee > 0) {                                                                  // Jika ada fee\r\n            bool okFee = mfi.transfer(treasury, fee);                                   // Kirim fee ke treasury\r\n            require(okFee, \"MFI fee transfer failed\");\r\n        }\r\n\r\n        bool okUser = mfi.transfer(msg.sender, payout);                                 // Kirim sisa (principal-fee) ke user\r\n        require(okUser, \"MFI payout transfer failed\");\r\n\r\n        emit Redeemed(msg.sender, tokenId, principal, fee, payout);                     // Log redeem\r\n    }\r\n\r\n    /// @notice Simulasi hitung nilai redeem\r\n    function previewRedeem(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (uint256 principal, uint256 fee, uint256 payout)\r\n    {\r\n        uint8 roses = nft.roseCountOf(tokenId);          // Ambil jumlah mawar di NFT\r\n        principal = uint256(roses) * ROSE_UNIT;          // Total MFI sesuai jumlah mawar\r\n        fee = (principal * feeBps) / 10_000;             // Hitung fee berdasarkan bps\r\n        payout = principal - fee;                        // Nilai bersih user\r\n    }\r\n\r\n    /// @notice Get semua token IDs yang dimiliki user\r\n    /// @param user Alamat user yang dicari depositnya\r\n    /// @return Array dari token IDs yang dimiliki user\r\n    function getUserDeposits(address user) external view returns (uint256[] memory) {\r\n        if (user == address(0)) {\r\n            return new uint256[](0);\r\n        }\r\n        // Empty array if no deposits yet\r\n        if (userDeposits[user].length == 0) {\r\n            return new uint256[](0);\r\n        }\r\n        return userDeposits[user];\r\n    }\r\n    /**\r\n     * @notice Dipanggil otomatis oleh NFT contract setiap kali ada transfer antar user (via callback)\r\n     * @param from Alamat pemilik lama\r\n     * @param to Alamat pemilik baru\r\n     * @param tokenId ID NFT yang dipindahkan\r\n     */\r\n    function onNftTransfer(address from, address to, uint256 tokenId) external /* nonReentrant opsional */ {\r\n        // Hanya izinkan pemanggilan dari kontrak NFT resmi (biar gak bisa diserang kontrak luar)\r\n        require(msg.sender == address(nft), \"only nft\");\r\n\r\n        // =====================================================\r\n        // ========== HAPUS tokenId dari pemilik lama ==========\r\n        // =====================================================\r\n\r\n        // Ambil posisi (index+1) token di array userDeposits[from]\r\n        uint256 idxPlusOne = depositIndex[tokenId];\r\n\r\n        // Kalau token tersebut memang terdaftar di list userDeposits[from]\r\n        if (idxPlusOne > 0) {\r\n            // Kurangi 1 untuk dapetin index aslinya\r\n            uint256 idx = idxPlusOne - 1;\r\n\r\n            // Ambil index terakhir di array pemilik lama\r\n            uint256 lastIdx = userDeposits[from].length - 1;\r\n\r\n            // Jika token yang mau dihapus bukan elemen terakhir di array\r\n            if (idx != lastIdx) {\r\n                // Ambil token terakhir di array untuk swap\r\n                uint256 lastToken = userDeposits[from][lastIdx];\r\n\r\n                // Gantikan posisi token yang dihapus dengan token terakhir\r\n                userDeposits[from][idx] = lastToken;\r\n\r\n                // Update depositIndex untuk token yang ditukar posisinya\r\n                depositIndex[lastToken] = idx + 1;\r\n            }\r\n\r\n            // Hapus elemen terakhir (pop) karena sudah disalin ke posisi idx\r\n            userDeposits[from].pop();\r\n\r\n            // Reset index tokenId yang sudah dipindahkan ke 0 (tidak terdaftar di from lagi)\r\n            depositIndex[tokenId] = 0;\r\n        }\r\n\r\n        // =====================================================\r\n        // ===== TAMBAH tokenId ke pemilik baru (user to) ======\r\n        // =====================================================\r\n\r\n        // Tambahkan tokenId ke array milik pemilik baru\r\n        userDeposits[to].push(tokenId);\r\n\r\n        // Simpan posisi baru tokenId di array pemilik baru (index+1)\r\n        depositIndex[tokenId] = userDeposits[to].length;\r\n\r\n        // =====================================================\r\n        // ========== RESET buket aktif kalau perlu ============\r\n        // =====================================================\r\n\r\n        // Jika token yang dipindahkan adalah buket aktif si pemilik lama,\r\n        // maka reset activeBucketId[from] ke 0 (karena udah pindah tangan)\r\n        if (activeBucketId[from] == tokenId) {\r\n            activeBucketId[from] = 0;\r\n        }\r\n    }\r\n\r\n}\r\n"
      }
    }
  }
}